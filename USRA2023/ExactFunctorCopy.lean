import Mathlib.CategoryTheory.Limits.Preserves.Finite
import Mathlib.CategoryTheory.Limits.Shapes.Products
import Mathlib.CategoryTheory.Limits.Filtered
import Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers
import Mathlib.CategoryTheory.Abelian.Basic
import Mathlib.CategoryTheory.Adjunction.Limits


namespace CategoryTheory.Functor

open CategoryTheory Limits

variable {C : Type _} [Category C] {D : Type _} [Category D]

/-- TODO-/
class Exact (F : C ‚•§ D) extends PreservesFiniteLimits F, PreservesFiniteColimits F

instance (F : C ‚•§ D) [PreservesFiniteLimits F] [PreservesFiniteColimits F] : Exact F where

example (F : C ‚•§ D) [Exact F] : PreservesFiniteLimits F := inferInstance
example (F : C ‚•§ D) [Exact F] : PreservesFiniteColimits F := inferInstance

/-- TODO-/
def preservesFiniteLimitsOfNatIso (F : C ‚•§ D) {G : C ‚•§ D} [PreservesFiniteLimits F] (h : F ‚âÖ G) :
  PreservesFiniteLimits G where preservesFiniteLimits _ := ‚ü®preservesLimitOfNatIso _ h‚ü©

/-- TODO-/
def preservesFiniteColimitsOfNatIso (F : C ‚•§ D) {G : C ‚•§ D} [PreservesFiniteColimits F] (h : F ‚âÖ G) : 
  PreservesFiniteColimits G where preservesFiniteColimits _ := ‚ü®preservesColimitOfNatIso _ h‚ü©    

/-- TODO-/
def exactOfNatIso (F : C ‚•§ D) {G : C ‚•§ D} [Exact F] (h : F ‚âÖ G) : Exact G := 
  letI : PreservesFiniteLimits G := preservesFiniteLimitsOfNatIso _ h
  letI : PreservesFiniteColimits G := preservesFiniteColimitsOfNatIso _ h
  inferInstance

def exactComp {E : Type _} [Category E] 
  (F : C ‚•§ D) (G : D ‚•§ E) [Exact F] [Exact G] : Exact (F ‚ãô G) := sorry

class AB4 (ùìê : Type _) [Category.{v} ùìê] [Abelian ùìê] [HasCoproducts ùìê] where
  exact (Œ± : Type v) : Exact (colim : (Discrete Œ± ‚•§ ùìê) ‚•§ ùìê)

instance (ùìê : Type _) [Category.{v} ùìê] [Abelian ùìê] [HasCoproducts ùìê] [AB4 ùìê] (Œ± : Type v) : 
  Exact (colim : (Discrete Œ± ‚•§ ùìê) ‚•§ ùìê) := AB4.exact _

class AB5 (ùìê : Type _) [Category.{v} ùìê] [Abelian ùìê] [HasColimits ùìê] where
  exact (J : Type v) [SmallCategory J] [IsFiltered J] : Exact (colim : (J ‚•§ ùìê) ‚•§ ùìê)

/- Might help later? -/
noncomputable instance (ùìê : Type _) [Category.{v} ùìê] [Abelian ùìê] [HasCoproducts ùìê] (Œ± : Type v) : 
    PreservesColimitsOfSize (colim : (Discrete Œ± ‚•§ ùìê) ‚•§ ùìê) := 
  Adjunction.leftAdjointPreservesColimits colimConstAdj

variable {C : Type _} [Category.{v} C] 

example (Œ± : Type _) (S : Set Œ±) (a : Œ±) (ha : a ‚àà S) : S :=
  ‚ü®_, ha‚ü©

noncomputable abbrev coproductColimitDiagramMap {Œ± : Type v} (X : Œ± ‚Üí C)
    [HasFiniteCoproducts C] {S T : Finset Œ±} (h : S ‚â§ T) : 
    ‚àê (fun s : S => X s) ‚ü∂ ‚àê (fun t : T => X t) := 
  Sigma.desc fun s => Sigma.Œπ (fun t : T => X t) ‚ü®s.1, h s.2‚ü© 

@[simps]
noncomputable
def coproductColimitDiagram {Œ± : Type v} (X : Œ± ‚Üí C)
    [HasFiniteCoproducts C] : Finset Œ± ‚•§ C where
  obj S := ‚àê (fun s : S => X s)
  map {S T : Finset Œ±} (i : S ‚ü∂ T) := coproductColimitDiagramMap X i.le

@[simps]
noncomputable
def coproductColimitCocone {Œ± : Type v} (X : Œ± ‚Üí C) [HasColimits C] : 
    Cocone (coproductColimitDiagram X) where
  pt := ‚àê X
  Œπ := {
    app := fun S => show ‚àê (fun s : S => X s) ‚ü∂ ‚àê X from 
      Sigma.desc fun i => Sigma.Œπ _ i.1 }

-- def coproductCoconeFun {Œ± : Type v} (X : Œ± ‚Üí C) [HasColimits C] (c : Cocone (coproductColimitDiagram X)) : 
--   Cocone (Discrete.functor X) where
--   pt := c.pt
--   Œπ := {
--     app := fun I => by {
--       intro a

--     }
--   }

@[simps]
noncomputable
def coproductColimitCoconeIsColimit {Œ± : Type v} (X : Œ± ‚Üí C) [HasColimits C] : 
    IsColimit (coproductColimitCocone X) where
  desc S := Sigma.desc fun a => 
    letI e1 : X a ‚ü∂ ‚àê (fun b : ({a} : Finset Œ±) => X b) := 
      Sigma.Œπ (fun b : ({a} : Finset Œ±) => X b) ‚ü®a, by simp‚ü©
    letI e2 : ‚àê (fun b : ({a} : Finset Œ±) => X b) ‚ü∂ S.pt := S.Œπ.app {a}
    e1 ‚â´ e2
  fac := fun c S => by
    dsimp only [coproductColimitDiagram_obj, coproductColimitCocone_pt, 
      const_obj_obj, coproductColimitCocone_Œπ_app]
    apply Sigma.hom_ext
    rintro ‚ü®b,hb‚ü©   
    simp only [colimit.Œπ_desc_assoc, Discrete.functor_obj, Cofan.mk_pt, 
      Cofan.mk_Œπ_app, colimit.Œπ_desc]
    let e : ({b} : Finset Œ±) ‚ü∂ S := homOfLE (by simpa using hb)
    rw [‚Üê c.w e, ‚Üê Category.assoc] ; congr
    simp
  uniq :=  fun c œÉ h => by {
    dsimp only [coproductColimitCocone_pt]
    apply Sigma.hom_ext
    intros s
    simp only [colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app, ‚Üê h {s}, 
      coproductColimitDiagram_obj, coproductColimitCocone_pt, const_obj_obj,
      coproductColimitCocone_Œπ_app, colimit.Œπ_desc_assoc, Discrete.functor_obj,
      Cofan.mk_pt, Cofan.mk_Œπ_app]
  }

@[simps!]
noncomputable
def coproductIsoColimit {Œ± : Type v} (X : Œ± ‚Üí C) [HasColimits C] : 
    ‚àê X ‚âÖ colimit (coproductColimitDiagram X) := 
  (coproductColimitCoconeIsColimit X).coconePointUniqueUpToIso (colimit.isColimit _)

/-
noncomputable
def coproductIsoColimit' {Œ± : Type v} (X : Œ± ‚Üí C) [HasColimits C] : 
    ‚àê X ‚âÖ colimit (coproductColimitDiagram X) where
    hom := Sigma.desc fun a => 
      letI e1 : X a ‚ü∂ ‚àê (fun b : ({a} : Finset Œ±) => X b) := 
        Sigma.Œπ (fun b : ({a} : Finset Œ±) => X b) ‚ü®a, by simp‚ü©
      letI e2 : ‚àê (fun b : ({a} : Finset Œ±) => X b) ‚ü∂ colimit (coproductColimitDiagram X) := 
        colimit.Œπ (coproductColimitDiagram X) {a}
      e1 ‚â´ e2
    inv := colimit.desc (coproductColimitDiagram X) (coproductColimitCocone X)
    inv_hom_id := by 
      ext j
      simp only [coproductColimitDiagram_obj, colimit.Œπ_desc_assoc, coproductColimitCocone_Œπ_app]
      ext jj
      simp only [colimit.Œπ_desc_assoc, Cofan.mk_Œπ_app, colimit.Œπ_desc]
      have leq : {‚Üëjj} ‚â§ j := Iff.mpr Finset.subset_iff (fun _ x =>
       by simp [Finset.eq_of_mem_singleton x])
      rw [‚Üê(colimit.w (coproductColimitDiagram X) <| homOfLE leq)]
      simp
    hom_inv_id := by aesop_cat

example {Œ± : Type v} (X : Œ± ‚Üí C) [HasColimits C] :
  coproductIsoColimit' X = coproductIsoColimit X := rfl
-/

-- noncomputable
-- def coproductIsoColimit {Œ± : Type v} (X : Œ± ‚Üí C) [HasColimits C] : 
--     ‚àê X ‚âÖ colimit (coproductColimitDiagram X) where
--     hom := Sigma.desc fun a => 
--       letI e1 : X a ‚ü∂ ‚àê (fun b : ({a} : Finset Œ±) => X b) := 
--         Sigma.Œπ (fun b : ({a} : Finset Œ±) => X b) ‚ü®a, by simp‚ü©
--       letI e2 : ‚àê (fun b : ({a} : Finset Œ±) => X b) ‚ü∂ colimit (coproductColimitDiagram X) := 
--         colimit.Œπ (coproductColimitDiagram X) {a}
--       e1 ‚â´ e2
--     inv := colimit.desc (coproductColimitDiagram X) (coproductColimitCocone X)
--     inv_hom_id := by 
--       ext j; simp
--       ext jj; simp
--       have leq : {‚Üëjj} ‚â§ j := Iff.mpr Finset.subset_iff (fun _ x =>
--        by simp [Finset.eq_of_mem_singleton x])
--       rw [‚Üê(colimit.w (coproductColimitDiagram X) <| homOfLE leq)]
--       simp
--     hom_inv_id := by aesop_cat

@[simps]
noncomputable
def coproductDiagramNatTrans {Œ± : Type v} {X Y : Œ± ‚Üí C} (Œ∑ : X ‚ü∂ Y) [HasColimits C] :
    coproductColimitDiagram X ‚ü∂ coproductColimitDiagram Y where
  app S := Limits.Sigma.map fun b => Œ∑ b

@[simps]
noncomputable
def changeCoproductCocone {Œ± : Type v} {X Y : Œ± ‚Üí C} (Œ∑ : X ‚ü∂ Y) [HasColimits C] :
    Cocone (coproductColimitDiagram X) where
  pt := colimit (coproductColimitDiagram Y)
  Œπ := {
    app := fun S => (coproductDiagramNatTrans Œ∑).app _ ‚â´ colimit.Œπ _ S
    naturality := fun X‚ÇÅ Y‚ÇÅ f => by
      apply Sigma.hom_ext
      intro s
      simp only [coproductDiagramNatTrans]
      rw [‚Üê(colimit.w (coproductColimitDiagram Y) f)]
      simp only [const_obj_obj, coproductColimitDiagram_obj, coproductColimitDiagram_map, colimit.Œπ_desc_assoc,
        Discrete.functor_obj, Cofan.mk_pt, Cofan.mk_Œπ_app, Œπ_colimMap_assoc, Discrete.natTrans_app, const_obj_map,
        Category.comp_id]
    }

@[simps]
noncomputable
def finsetColimitDiagram (Œ± : Type v) [HasColimits C] : 
    (Discrete Œ± ‚•§ C) ‚•§ C  where
  /- (F.obj ‚àò Discrete.mk) vs (fun b => X.obj {as := b})     -/
  obj := fun F => colimit (coproductColimitDiagram (fun j => F.obj ‚ü®j‚ü©))
  map := fun {F G} Œ∑ => colimit.desc _ (changeCoproductCocone fun b => Œ∑.app _)
  map_id := fun X => by 
    apply colimit.hom_ext
    intro j‚ÇÅ
    apply colimit.hom_ext
    intro b
    have h : (coproductDiagramNatTrans fun b => ùüô (X.obj { as := b })).app j‚ÇÅ = ùüô _ := by
      dsimp only [coproductColimitDiagram_obj]
      simp only [coproductDiagramNatTrans]
      ext
      simp
    simp [changeCoproductCocone, h]
    erw [Category.id_comp]
  --map_comp := sorry

/-
noncomputable
def discreteToFinsetMap {Œ± : Type v} [HasColimits C] {F G : Discrete Œ± ‚•§ C} (f : F ‚ü∂ G) :
    F.obj ‚àò Discrete.mk ‚ü∂ G.obj ‚àò Discrete.mk := --by {have h := f.app; aesop_cat}
  fun _ => f.app _
-/
  
noncomputable
def discreteToFinset (Œ± : Type v) [HasColimits C] :
    (Discrete Œ± ‚•§ C) ‚•§ (Finset Œ± ‚•§ C) where
  obj := fun F => coproductColimitDiagram (fun j => F.obj ‚ü®j‚ü©) --(fun b => F.obj {as := b}) --
  map := fun {F G} f => coproductDiagramNatTrans (fun j => f.app _)
  map_id := fun X => by 
    ext j
    have h : (coproductDiagramNatTrans fun b => ùüô (X.obj { as := b })).app j = ùüô _ := by 
      dsimp only [coproductColimitDiagram_obj]
      simp only [coproductDiagramNatTrans]
      ext
      simp
    exact h
  map_comp := fun {X Y Z} f g => by 
    simp only [coproductDiagramNatTrans]
    aesop_cat

-- def discreteToFinsetReflectionHom {Œ± : Type v} [HasColimits C] {J : Type} [SmallCategory J] [FinCategory J] (F G : J ‚•§ (Discrete Œ± ‚•§ C))
--   (Œπ : (F ‚ãô discreteToFinset Œ±) ‚ü∂ (G ‚ãô discreteToFinset Œ±)) : F.obj i ‚ü∂ G.obj i where
--     app :=


    


--the natural transformation we get by restricting to singletons
-- def discreteToFinsetReflectionNat {Œ± : Type v} [HasColimits C] {J : Type} [SmallCategory J] [FinCategory J] (F G : J ‚•§ (Discrete Œ± ‚•§ C))
--   (h : (F ‚ãô discreteToFinset Œ±) ‚ü∂ (G ‚ãô discreteToFinset Œ±)) : F ‚ü∂ G where
--     app := fun i => {
--       app := fun a => by {
--         sorry
--       }
--     }
--     naturality := sorry
  

def discreteCoconeFromFinsetCocone {Œ± : Type v} [HasColimits C] {J : Type} [SmallCategory J] [FinCategory J] (K : J ‚•§ (Discrete Œ± ‚•§ C)) 
  (s : Cocone (K ‚ãô discreteToFinset Œ±)) : Cocone K where
    pt := Discrete.functor (fun a => s.pt.obj {a})
    Œπ := {
      app := fun j => Discrete.natTrans (fun a => by {
        simp only [const_obj_obj]
        have h : (K.obj j).obj a ‚âÖ ((K ‚ãô discreteToFinset Œ±).obj j).obj {a.as} := by
          sorry
        letI := (s.Œπ.app j).app {a.as}
        sorry
      })
          
      naturality := sorry

    }
    -- by
    --   have f : (const J).obj s.pt ‚ü∂ (const J).obj (Discrete.functor fun a => s.pt.obj {a}) ‚ãô discreteToFinset Œ± := by {
    --     sorry
    --   }
    --   exact (discreteToFinsetReflectionNat K _ (s.Œπ ‚â´ f))


-- will be where biproducts come into play (or at least in the limit equivalent)
def discreteToFinsetOnFromFinsetCoconeIso {Œ± : Type v} [HasColimits C] {J : Type} [SmallCategory J] [FinCategory J] (K : J ‚•§ (Discrete Œ± ‚•§ C)) 
  (s : Cocone (K ‚ãô discreteToFinset Œ±)) : ((discreteToFinset (C := C) Œ±).mapCocone (discreteCoconeFromFinsetCocone K s)).pt ‚âÖ s.pt where
    hom := {
      app := sorry
      naturality := sorry
    }
    inv := sorry
    hom_inv_id := sorry
    inv_hom_id := sorry

      

-- def inclHom {Œ± : Type v} [HasColimits C] {J : Type} [SmallCategory J] [FinCategory J] (K : J ‚•§ (Discrete Œ± ‚•§ C)) 
--   (s : Cocone (K ‚ãô discreteToFinset Œ±)) : (discreteCoconeFromFinsetCocone K s).pt ‚ü∂ s.pt where

noncomputable
def idk {Œ± : Type v} [HasColimits C] {J : Type} [SmallCategory J] [FinCategory J] (K : J ‚•§ (Discrete Œ± ‚•§ C))  :
  PreservesColimit K (discreteToFinset (C := C) Œ±) where
    preserves := fun c => {
      desc := fun s => ((discreteToFinset (C := C) Œ±).mapCoconeMorphism ({ Hom := (c.desc (discreteCoconeFromFinsetCocone K s)) })).Hom ‚â´ 
        (discreteToFinsetOnFromFinsetCoconeIso K s).hom
      fac := fun s j => by
        simp only [comp_obj, mapCocone_pt, const_obj_obj, mapCocone_Œπ_app]
        sorry
      uniq := by 
        sorry
    }

def discreteCoconeFromFinsetCone {Œ± : Type v} [HasColimits C] {J : Type} [SmallCategory J] [FinCategory J] (K : J ‚•§ (Discrete Œ± ‚•§ C)) 
  (s : Cone (K ‚ãô discreteToFinset Œ±)) : Cone K where
    pt := Discrete.functor (fun a => s.pt.obj {a})
    œÄ := sorry

noncomputable
def idk2 {Œ± : Type v} [HasColimits C] {J : Type} [SmallCategory J] [FinCategory J] (K : J ‚•§ (Discrete Œ± ‚•§ C))  :
  PreservesLimit K (discreteToFinset (C := C) Œ±) where
    preserves := fun c => {
      lift := sorry
      fac := fun s j => by 
        sorry
      uniq := by 
        sorry
    }

-- This will use the fact that finite products (or coproducts) in an abelian category are exact.
-- the reason is that finite (co)products are isomorphic to finite biproducts, which are both limits and colimits, and
-- thus commute with both limits and colimits.  

noncomputable
def preservesColimitsOfFiniteShapeDiscreteToFinset (Œ± : Type v) [HasColimits C] (J : Type) [SmallCategory J] [FinCategory J] : 
  PreservesColimitsOfShape J (discreteToFinset (C := C) Œ±) where
    preservesColimit := idk _

noncomputable
def preservesLimitsOfFiniteShapeDiscreteToFinset (Œ± : Type v) [HasColimits C] (J : Type) [SmallCategory J] [FinCategory J] : 
  PreservesLimitsOfShape J (discreteToFinset (C := C) Œ±) where
    preservesLimit := idk2 _

-- instance (Œ± : Type v) [HasCoLimits C] : PreservesFiniteLimits (discreteToFinset (C := C) Œ±) := sorry


noncomputable
def rightExactDiscreteToFinset (Œ± : Type v) [HasColimits C] : PreservesFiniteColimits (discreteToFinset (C := C) Œ±) where
  preservesFiniteColimits := fun J => preservesColimitsOfFiniteShapeDiscreteToFinset _ J

noncomputable
def leftExactDiscreteToFinset (Œ± : Type v) [HasColimits C] : PreservesFiniteLimits (discreteToFinset (C := C) Œ±) where
  preservesFiniteLimits := fun J => preservesLimitsOfFiniteShapeDiscreteToFinset _ J

def exactDiscreteToFinset (Œ± : Type v) [HasColimits C] : Exact (discreteToFinset (C := C) Œ±) := 
  sorry

noncomputable
def finsetColimitDiagram' (Œ± : Type v) [HasColimits C] :
    (Finset Œ± ‚•§ C) ‚•§ C := colim 

noncomputable
def coproductFunctorIsoColimit (Œ± : Type v) [HasColimits C] :
    (colim : (Discrete Œ± ‚•§ C) ‚•§ C) ‚âÖ finsetColimitDiagram Œ± :=
  NatIso.ofComponents (fun F => 
    HasColimit.isoOfNatIso (Discrete.natIsoFunctor (F := F))
    ‚â™‚â´ coproductIsoColimit _) <| by
  rintro ‚ü®x‚ü© ‚ü®y‚ü© f
  apply colimit.hom_ext
  rintro ‚ü®j‚ü© 
  dsimp [Function.comp]
  simp

noncomputable
def actuallyUsefulIso (Œ± : Type v) [HasColimits C] : 
    (colim : (Discrete Œ± ‚•§ C) ‚•§ C) ‚âÖ  
    discreteToFinset Œ± ‚ãô colim := 
  coproductFunctorIsoColimit Œ± 

--noncomputable
--def exactDiscreteToFinset' (Œ± : Type v) [HasColimits C] : Exact (discreteToFinset (C := C) Œ±) := sorry

noncomputable instance (Œ± : Type v) : DecidableEq Œ± := Classical.decEq Œ±

noncomputable
instance [Abelian C] [HasColimits C] [AB5 C] : AB4 C := by
  constructor
  intro Œ±
  suffices Exact (discreteToFinset (C := C) Œ± ‚ãô colim) by 
    apply exactOfNatIso _ (actuallyUsefulIso Œ±).symm
  -- letI : IsFiltered (Finset Œ±) := inferInstance
  letI : Exact (colim : (Finset Œ± ‚•§ C) ‚•§ C) := AB5.exact _
  suffices Exact (discreteToFinset (C := C) Œ±) by
    apply exactComp  
  exact (exactDiscreteToFinset Œ±)

end CategoryTheory.Functor